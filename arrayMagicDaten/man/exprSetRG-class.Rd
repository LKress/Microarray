%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file was automatically generated by Rdoc on 2006-09-18 11:46:10.
% Do NOT modify this file, instead modify the source (/net/lima/export/raid1/rzpd/home/buness/R/Rpacks/arrayMagic/R/exprSetRG-class.R).
% Rdoc is copyright (C) 2001, Henrik Bengtsson, henrikb@braju.com.
% Download the Rdoc compiler at http://www.braju.com/R/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\name{exprSetRG-class}
\docType{class}

\alias{exprSetRG-class}
\alias{exprSetRG}
\alias{as.exprSet}
\alias{getExprSetGreen}
\alias{getExprSetGreenMinusRed}
\alias{getExprSetRedMinusGreen}
\alias{getExprSetRed}
\alias{getExprSetLogRatio}
\alias{getIndGreen}
\alias{getIndRed}
\alias{pDataGreen}
\alias{pDataRed}
\alias{pDataSlide}
\alias{phenoDataGreen}
\alias{phenoDataRed}
\alias{phenoDataSlide}
\alias{slideSubset}

\alias{[,exprSetRG-method}
\alias{as.exprSet,exprSetRG-method}
\alias{as.RGList,exprSetRG-method}
\alias{getExprSetGreen,exprSetRG-method}
\alias{getExprSetGreenMinusRed,exprSetRG-method}
\alias{getExprSetRedMinusGreen,exprSetRG-method}
\alias{getExprSetRed,exprSetRG-method}
\alias{getExprSetLogRatio,exprSetRG-method}
\alias{getIndGreen,exprSetRG-method}
\alias{getIndRed,exprSetRG-method}
\alias{initialize,exprSetRG-method}
\alias{pDataGreen,exprSetRG-method}
\alias{pDataRed,exprSetRG-method}
\alias{pDataSlide,exprSetRG-method}
\alias{phenoDataGreen,exprSetRG-method}
\alias{phenoDataRed,exprSetRG-method}
\alias{phenoDataSlide,exprSetRG-method}
\alias{show,exprSetRG-method}
\alias{slideSubset,exprSetRG-method}



 \title{Class exprSetRG for two colour DNA microarray data
        (extension of exprSet)} 

 \description{ This is a class representation for two colour
               DNA microarray data. The class is based on the
               class \code{exprSet} of the \code{Biobase} package.
               The red and green channels  are stored in a
               single \code{exprSet} object. The information on the
               corresponding red-green pairs is stored separately.
               Several class methods offer a convienent way
               to access and set data.
               }


\section{Creating Objects}{
\code{  new('exprSetRG',}\cr
\code{    channels = ..., # object of class matrix with columns "green" and "red" }\cr
\code{    exprs    = ..., # object of class matrix}\cr
\code{    se.exprs = ..., # object of class matrix}\cr
\code{    phenoData= ..., # object of class phenoData}\cr
\code{    notes    = ..., # object of class character}\cr
\code{    annotation    = ..., # object of class character}\cr
\code{  )}}

\section{Slots}{
  \describe{
    \item{\code{indGreen}:}{Object of class \code{vector}; indexes of the
      green channel}
    \item{\code{indRed}:}{Object of class \code{vector}; indexes of the
      red channel}
    \item{\code{exprs}:}{Object of class \code{matrix}; the observed
      expression levels. This is a matrix with columns representing
      the red and green channels and rows representing genes. Each row
      in \code{channels} lists the indexes of the corresponding
      pair of red and green channels representing a single
      microarray slide.}
    \item{\code{se.exprs}:}{Object of class \code{matrix}; this is
      a matrix of the same dimensions as \code{exprs}, e.g. useful to
      represent the standard error estimates for the corresponding
      expression levels. }
    \item{\code{phenoData}:}{Object of class \code{phenoData}, i.e.
      an instance of class \code{phenoData} 
      containing annotation information on the individual channels.
      The columns of the pData slot of this entity represent
      variables and the rows represent channels. }
    \item{\code{notes}:}{Object of class \code{character} containing
      explanatory text; default: ""}
    \item{\code{annotation}:}{Object of class \code{character};
      default: ""}
  }
}

\section{Extends}{
Class \code{exprSet}, directly.
}


 \section{Methods}{
  \describe{

    \item{show}{(exprSetRG):
      renders information about the exprSetRG
      in a concise way on stdout, cf. class exprSet.}
    
    \item{getExprSetLogRatio}{(exprSetRG, seExprsHandling):
      Returns an \code{exprSet}
      object of the difference of the expression levels, i.e. the green
      channel minus the red channel. 
      The \code{phenoData} slot it the result
      of calling the class method \code{phenoDataSlide}
      on the object \code{exprSetRG}.
      The \code{se.exprs} slot contains
      the root-mean-square or the mean of the se.exprs of both channels
      depending on the argument \code{seExprsHandling}.
      The root-mean-square might be useful if the two
      se.exprs values are estimated standard deviations
      based on the same number observations and identical
      distribution. \code{seExprsHandling} must be a character string;
      possible values are "rootMeanSquare" or "mean";
      the default value is "rootMeanSquare". }

    \item{getExprSetGreenMinusRed}{ same as method
      \code{getExprSetLogRatio} }

    \item{getExprSetRedMinusGreen}{ similar to method
      \code{getExprSetLogRatio}; the "negative" difference
      of the expression levels is returned, i.e. the red
      channel minus the green channel.
      }

    \item{getExprSetGreen}{(exprSetRG): Returns an \code{exprSet}
      object which contains the expression levels of the green channel
      and the corresponding annotation.}
    
    \item{getExprSetRed}{(exprSetRG): Returns an \code{exprSet}
      object which contains the expression levels of the red channel
      and the corresponding annotation.}

    \item{phenoDataSlide}{(exprSetRG): Returns an \code{phenoData}
      object characterizing all microarray slides.
      Those annotation information, which is the same for both channels
      (and not \code{NA}) is taken directly, e.g. the
      the slide number. All other annotation variables are added
      specifically for each channel, i.e. prefixed with
      "greenSpecific\_" and "redSpecific\_".
      Do not use varLabels-names for subsetting.}
      
    \item{pDataSlide}{(exprSetRG): Returns an \code{pData}
      object, i.e. \code{pData(phenoDataSlide(exprSetRG))};
      cf. \code{phenoDataSlide}.
      Do not use varLabels-names for subsetting.}

    \item{phenoDataGreen}{(exprSetRG): Returns an \code{phenoData}
      object of the annotation information given for the green channel.
      Do not use varLabels-names for subsetting.}
      
    \item{pDataGreen}{(exprSetRG): Returns the \code{pData}
      object taken out of the result of calling \code{phenoDataGreen}.
      Do not use varLabels-names for subsetting.}

    \item{phenoDataRed}{(exprSetRG): Returns an \code{phenoData}
      object of the annotation information given for the red channel.
      Do not use varLabels-names for subsetting.}
      
    \item{pDataRed}{(exprSetRG): Returns the \code{pData}
      object taken out of the result of calling \code{phenoDataRed}.
      Do not use varLabels-names for subsetting.}

    \item{slideSubset}{(exprSetRG,i,j): Subsetting operation; where
      i corresponds to the rows  and j corresponds to the
      microarray slides.
      j is given by indexes or logicals related to the order
      of the channel pairs in \code{channels};
      cf. the constructor slot \code{channels}.}

    \item{getIndGreen}{(exprSetRG): An accessor function for slot
      \code{indGreen}. The corresponding elements of indGreen and indRed
      define microarray slides.}

    \item{getIndRed}{(exprSetRG): An accessor function for slot
      \code{indRed}. The corresponding elements of indGreen and indRed
      define microarray slides.}

    \item{[}{(exprSetRG,i,j,type):
      A subset operator.
      Ensures that both the data and the annotation
      information (\code{phenoData}) are subseted properly.
      This may only mix up the pairing of the channels,
      i.e. the validity of an exprSetRG,
      if you use argument option type == "invalidExprSetRG".
      Default: "validExprSetRG". See also: \code{slideSubset}.}

    \item{cbind}{(...): Concatenates \code{exprSetRG} objects.
                        Genes (rows) are assumed to match;
                        cf. \code{\link{cbind.exprSetRG}} }

    \item{as.exprSet}{(exprSetRG): Class cast, returns an object of
      \code{exprSet}, the information on the red and green channels
      is discarded.}

    \item{as.RGList}{(exprSetRG, func): Returns an object of
      \code{RGList} which in general refers to raw data.
      Hence, func(expression values) is returned, i.e.
      \code{exp(x)} by default.
      All background values in the RGList object are
      set to zero.}

  }
}
 
 \keyword{classes}
 \keyword{methods}

 \examples{
  indGreen=1:3
  indRed=4:6
  channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
  colnames(channels) <- c("green","red")
  eSA <- new("exprSetRG", exprs=matrix(1:60, ncol=6, nrow=10), phenoData=
          new("phenoData", pData=data.frame(matrix(0,nrow=6,ncol=1)),
              varLabels=list(rep("varLabel1",1))), channels=channels)
  stopifnot( all(pDataSlide(eSA) ==pData(eSA)[1:3,,drop=FALSE]) )
  eSAGreen <- getExprSetGreen(eSA)
  eSARed <- getExprSetRed(eSA)
  eSALogRatio <- getExprSetLogRatio(eSA)
  eSALogRatio2 <- getExprSetGreenMinusRed(eSA)
  eSALogRatio3 <- getExprSetRedMinusGreen(eSA)
  stopifnot( identical( eSALogRatio, eSALogRatio2 ) )
  stopifnot( identical( exprs(eSALogRatio), exprs(eSAGreen)-exprs(eSARed)) )
  stopifnot( all.equal.numeric( as.vector(exprs(eSALogRatio3)), as.vector(exprs(eSARed)-exprs(eSAGreen)) ))
  eSAPart <- eSA[,c(1,3,1,4,6,4)]
  eSAInvalid <- eSA[,c(1,3,1,5,6,4),type="invalidExprSetRG"]
  eSAPart2 <- slideSubset(eSA,j=c(1,3,1))

  eSAeSA <- cbind(eSA, eSA)
  eSAeSAPart2 <- cbind(eSA, eSAPart2)
  stopifnot( class(as.exprSet(eSA)) == "exprSet" )

  \dontshow{
  rg <- as.RGList(eSA)
  stopifnot( identical( exprs(eSAPart), exprs(eSAPart2) ) )
  ind <- c(1,1,3,2,3,3)
  stopifnot( identical( exprs(eSALogRatio[,ind]), exprs(eSAGreen[,ind])-exprs(eSARed[,ind])) )
  stopifnot( dim(exprs(eSALogRatio[,ind]))[2] == length(ind) )
  eSAPart <- eSA[,1:3, type="invalidExprSetRG"] # not recommended
  stopifnot(identical(eSAGreen, getExprSetGreen(eSAPart)))
  #stopifnot(identical(eSAGreen[,c(1,1,1)], getExprSetGreen(eSAPart[,c(1,1,1),type="invalidExprSetRG"])))
  stopifnot(all.equal.numeric(as.vector(exprs(eSAGreen[,c(1,1,1)])), as.vector(exprs(getExprSetGreen(eSAPart[,c(1,1,1),type="invalidExprSetRG"])))))
  #stopifnot(identical(eSAGreen[,c(TRUE,TRUE,TRUE)], getExprSetGreen(eSAPart[,c(TRUE,TRUE,TRUE),type="invalidExprSetRG"])))
  stopifnot(all.equal.numeric(exprs(eSAGreen[,c(TRUE,TRUE,TRUE)]), exprs(getExprSetGreen(eSAPart[,c(TRUE,TRUE,TRUE),type="invalidExprSetRG"]))))
  #stopifnot(identical(eSAGreen[,c(FALSE,FALSE,FALSE)], getExprSetGreen(eSAPart[,c(FALSE,FALSE,FALSE), type="invalidExprSetRG"])))
  stopifnot(all.equal.numeric(exprs(eSAGreen[,c(FALSE,FALSE,FALSE)]), exprs(getExprSetGreen(eSAPart[,c(FALSE,FALSE,FALSE), type="invalidExprSetRG"]))))
  #stopifnot(identical(eSAGreen[,c(FALSE,TRUE,FALSE)], getExprSetGreen(eSAPart[,c(FALSE,TRUE,FALSE), type="invalidExprSetRG"])))
  stopifnot(all.equal.numeric(exprs(eSAGreen[,c(FALSE,TRUE,FALSE)]), exprs(getExprSetGreen(eSAPart[,c(FALSE,TRUE,FALSE), type="invalidExprSetRG"]))))
  print(eSA)
  print(phenoDataSlide(eSA))
  print(pDataSlide(eSA))
  print(phenoDataGreen(eSA))
  print(pDataGreen(eSA))
  print(phenoDataRed(eSA))
  print(pDataRed(eSA))

  indGreen <- c(2,4); indRed <- c(1,3)
  channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
  colnames(channels) <- c("green","red")
  myPData <- data.frame(commonOne=c(1,1,2,2), first=c(1,2,3,4))
  myPDataTwo <- data.frame(commonOne=c(1,1,2,2), second=c("a","b","a","b"))
  myPDataThree <- data.frame(commonOne=c(1,1,2,2))
  myPhenoData <- new("phenoData", pData=myPData, varLabels=as.list(colnames(myPData)))
  myPhenoDataTwo <- new("phenoData", pData=myPDataTwo, varLabels=as.list(colnames(myPDataTwo)))
  myPhenoDataThree <- new("phenoData", pData=myPDataThree, varLabels=as.list(colnames(myPDataThree)))
  myMatrix <- cbind(c(1,1,1,1),c(2,2,2,2),c(3,3,3,3),c(4,4,4,4))
  myExprSetRG <- new("exprSetRG", exprs=myMatrix, se.exprs=myMatrix, phenoData=myPhenoData, channels=channels)
  myExprSetRGTwo <- new("exprSetRG", exprs=myMatrix, se.exprs=myMatrix, phenoData=myPhenoDataTwo, channels=channels)
  myExprSetRGThree <- new("exprSetRG", exprs=myMatrix, se.exprs=myMatrix, phenoData=myPhenoDataThree, channels=channels)
  stopifnot( all.equal.numeric(as.vector(se.exprs(getExprSetGreen(myExprSetRG))), as.vector(cbind(c(2,2,2,2),c(4,4,4,4)))))
  stopifnot( all.equal.numeric(as.vector(se.exprs(getExprSetRed(myExprSetRG))),as.vector( cbind(c(1,1,1,1),c(3,3,3,3)))))
  stopifnot( all.equal.numeric(as.vector(se.exprs(getExprSetLogRatio(myExprSetRG, seExprsHandling="mean"))), as.vector(0.5*cbind(c(3,3,3,3),c(7,7,7,7)))))
  stopifnot( all.equal.numeric(as.vector(se.exprs(myExprSetRG[2,])) , c(1,2,3,4)) )
  stopifnot( all.equal.numeric(as.vector(se.exprs(myExprSetRG[2,3:4])) , c(3,4)) )
  stopifnot( all.equal.numeric( as.vector(se.exprs(cbind(myExprSetRG,myExprSetRG))), as.vector(cbind(se.exprs(myExprSetRG),se.exprs(myExprSetRG))) ))
  stopifnot( all.equal.numeric(as.vector(exprs(getExprSetLogRatio(myExprSetRG))), as.vector(matrix(1,ncol=2,nrow=4))))
  cTwo <- cbind(myExprSetRG, myExprSetRGTwo)
  cThree <- cbind(myExprSetRG, myExprSetRGTwo, myExprSetRGThree)
  cTwob <- cbind(myExprSetRG, myExprSetRGThree)
  # match corresponds to \%in\% , i.e. %in%
  stopifnot( all( match(varLabels(cTwo),  c("commonOne", "first", "second")) ) ) 
  stopifnot( all( match(varLabels(cTwob),c("commonOne", "first")) ) )
  stopifnot( all( match(varLabels(cThree), c("commonOne", "first", "second")) ) )
  stopifnot( all( pData(cTwo)[,"commonOne"] ==  pData(cTwob)[,"commonOne"] ) )

  indGreen <- c(2,4,6); indRed <- c(1,3,5)
  channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
  colnames(channels) <- c("green","red")
  myPData <- data.frame(commonOne=c(1,1,2,2,3,3), commonTwo=c(1,1,1,1,2,2), redOne=c(1,NA,2,NA,3,NA), redTwo=c(1,-1,2,-1,3,-1), greenOne=c(NA,10,NA,20,NA,30), greenTwo=c(-10,10,-10,20,-10,30))
  myPhenoData <- new("phenoData", pData=myPData, varLabels=as.list(colnames(myPData)))
  myExprSetRG <- new("exprSetRG", exprs=matrix(1,nrow=10,ncol=6), phenoData=myPhenoData, channels=channels)
  stopifnot( all( myPData[indGreen,] == pDataGreen(myExprSetRG) ,na.rm=TRUE) )
  stopifnot( all( myPData[indGreen,] == pDataGreen(myExprSetRG) ,na.rm=TRUE) )
  stopifnot( identical(varLabels(myPhenoData[indRed, ]), varLabels(phenoDataRed(myExprSetRG))) )
  stopifnot( identical( varLabels(myPhenoData[indGreen,]), varLabels(phenoDataGreen(myExprSetRG))) )
 stopifnot(all(pData(myPhenoData[indRed,]) == pData(phenoDataRed(myExprSetRG)), na.rm=TRUE))
 stopifnot(all(pData(myPhenoData[indGreen,]) == pData(phenoDataGreen(myExprSetRG)), na.rm=TRUE))
  stopifnot( all( pDataSlide(myExprSetRG)[,c("commonOne","commonTwo")] == pDataRed(myExprSetRG)[,c("commonOne","commonTwo")] ) )
  stopifnot( all( pDataSlide(myExprSetRG)[,c("commonOne","commonTwo")] == pDataGreen(myExprSetRG)[,c("commonOne","commonTwo")] ) )
  stopifnot( all( pDataSlide(myExprSetRG)[,c("greenSpecific_greenOne","greenSpecific_greenTwo")] == pDataGreen(myExprSetRG)[,c("greenOne","greenTwo")] ) )
  stopifnot( all( pDataSlide(myExprSetRG)[,c("redSpecific_redOne","redSpecific_redTwo")] == pDataRed(myExprSetRG)[,c("redOne","redTwo")] ) )
  stopifnot( all( pDataSlide(myExprSetRG)[,c("greenSpecific_redTwo")] == pDataGreen(myExprSetRG)[,c("redTwo")] ) )
  stopifnot( all( pDataSlide(myExprSetRG)[,c("redSpecific_greenTwo")] == pDataRed(myExprSetRG)[,c("greenTwo")] ) )
  }
 }

  \seealso{ \code{exprSet-class},
            \code{\link{arrayData-class}}
          }

 \author{Andreas Buness <a.buness@dkfz.de>}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End of File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
