%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file was automatically generated by Rdoc on 2006-04-12  8:38:17.
% Do NOT modify this file, instead modify the source (/buness/R/TestingOfarrayMagic/Rpacks/arrayMagic/R/qualityParameters.R).
% Rdoc is copyright (C) 2001, Henrik Bengtsson, henrikb@braju.com.
% Download the Rdoc compiler at http://www.braju.com/R/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


 \name{qualityParameters}

 \title{Calculation of quality characteristics for
        DNA microarray hybridisations}

 \alias{qualityParameters}

 \description{Several quality measures are calculated.
              The return value, i.e. a list of quality scores,
              should be used as input argument for the function
              \code{\link{qualityDiagnostics}}.
              For details on the quality measures
              read the value section. } 

 \usage{qualityParameters(arrayDataObject, exprSetRGObject, spotIdentifier = "Name", slideNameColumn = "slideName", identifiersToBeSkipped=NA, resultFileName, verbose = TRUE)}

 \value{returns a list of results, i.e. a
   \code{data.frame} \code{qualityParameters} containing
   several scores for each hybridisation, as well as
   pairwise comparisons, i.e.
   a matrix \code{slideDistance},
   a matrix \code{slideDistanceLogRaw},
   a matrix \code{slideDistanceGreen},
   a matrix \code{slideDistanceGreenLogRaw},
   a matrix \code{slideDistanceRed},
   a matrix \code{slideDistanceRedLogRaw},
   and an integer \code{replicateSpots},
   i.e. the number of detected spot replicas.
 
   The matrix \code{slideDistanceLogRaw} contains a  calculated
   distance (similarity) for each pair of slides$_{ij}$,
   i.e. the median absolute deviation (mad)
   taken over all spots of the log-ratio of the raw data;
   alike the matrix \code{slideDistance}
   the mad taken over all spots of the difference
   of the log-ratios 
   (here: the difference of the normalised and transformed
          expression values of the two channels on the slide).
   Similarly the matrices  \code{slideDistanceGreen},
   \code{slideDistanceGreenLogRaw},
   \code{slideDistanceRed},
   and \code{slideDistanceRedLogRaw} contain calculated distances
   for each pair of slides$_{ij}$ based on the mad of the difference
   of the same channel (normalised or logged) taken over all spots.
   

   A brief summary of all parameters given in
   the \code{data.frame} \code{qualityParameters}:

   \code{width}
   a robust estimate of the noise, i.e. the median absolute deviation
   of the difference of the normalised channels taken over all spots, i.e.
   the "width" of the scatterplot

   \code{medianDistance}
   a robust measure for the typical distance (similarity) of one slide
   with all other slides, i.e. the median of the "distances"
   between slides (c.f. \code{slideDistance}))

   \code{correlation(LogRaw)}
   of the expression values between the two normalised (log raw) channels
   of the slide taken over all spots

   \code{meanSignalGreen}
   the mean taken over all spots of the green raw data channel 

   \code{meanSignalRed}
   the mean taken over all spots of the red raw data channel

   \code{meanSignal}
   mean taken over all spots of the raw data of both channels,

   \code{signalRangeGreen}
   the range between the 10th and 95th percentile
   of the signal intensities given in the green raw data channel

   \code{signalRangeRed}
   the range between the 10th and 95th percentile
   of the signal intensities given in the red raw data channel

   \code{backgroundRangeGreen}
   the range between the 10th and 95th percentile
   of the background intensities given in the green raw data channel

   \code{backgroundRangeRed}
   the range between the 10th and 95th percentile
   of the background intensities given in the red raw data channel

   \code{signalToBackgroundGreen}
   the ratio of the median signal intensity and the median background
   intensity given in the green raw data channel

   \code{signalToBackgroundRed}
   the ratio of the median signal intensity and the median background
   intensity given in the red raw data channel

   \code{spotReplicatesConcordanceGreen(LogRaw)}
    the median of the standard deviations of all spot replicas
    for each unique identifier
    of the normalised (log raw) green channel is calculated;
    in case of duplicates, i.e.
    \code{replicateSpots == 2},
    the Pearson and Spearman correlation is calculated instead

   \code{spotReplicatesConcordanceGreen(LogRaw)}
    the median of the standard deviations of all spot replicas
    for each unique identifier
    of the normalised (log raw) green channel is calculated;
    in case of duplicates, i.e.
    \code{replicateSpots == 2},
    the Pearson and Spearman correlation is calculated instead

   \code{greenvsAllGreen} and \code{redvsAllRed}
   the correlation between each channel is measured against the
   averaged (median) channel over all hybridisations
   (like a virtual reference) separately for each channel
 }


 \arguments{
  \item{arrayDataObject}{object of type \code{\link{arrayData}};
                         required; default: missing}
  \item{exprSetRGObject}{object of type \code{\link{exprSetRG}};
                         required; default: missing}
  \item{spotIdentifier}{ character string; required; specifies a
                         column of \code{getSpotAttr(arrayDataObject)};
                         the column is used to determine spot replicas;
                         default: "Name"}
  \item{slideNameColumn}{ character string; required; specifies a
                          column of \code{getHybAttr(arrayDataObject)};
                          the column is used to extract the names
                          of the hybridisations; if not found
                          the hybridisations are consecutively numbered;
                          default: "slideName"}
  \item{identifiersToBeSkipped}{vector of character strings of
                                spot identifiers to be excluded
                                from calculations;
                                required; default: \code{NA}}
  \item{resultFileName}{character string; results are stored
                        in a tab-deliminated file if supplied;
                        default: missing}
  \item{verbose}{logical; default \code{TRUE}}
 }
 
 \details{For details on the quality measures read the value section.}

 \seealso{\code{\link{qualityDiagnostics}}}

  \examples{
      spotIdentifierVec <- c("A","A","Blank","B","B","Blank")
      hybNames <- "H1"
      R1 <- N1 <- c(1,1,9,2,2,10)
      R2 <- N2 <- c(2,2,7,4,4,8)
      rawDataIntensityValues <- array(0, dim=c(6,2,1))
      rawDataIntensityValues[,1,] <- R1
      rawDataIntensityValues[,2,] <- R2
      dimnames(rawDataIntensityValues) <- list(NULL, c("green","red"), NULL)
      spotAttr <- data.frame(Name=I(spotIdentifierVec))
      hybAttr <- data.frame(slideName=I(hybNames))
      arrayDataObject <- new("arrayData", intensities=rawDataIntensityValues, hybAttrList=list(red=hybAttr,green=hybAttr), spotAttr=spotAttr)
      indGreen <- 1
      indRed <- 2
      channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
      colnames(channels) <- c("green","red")
      exprSetRGObject <- new("exprSetRG", 	
      exprs <- matrix(c(R1,R2), nrow=6, byrow=FALSE), phenoData=	
          new("phenoData", pData=data.frame(matrix(0,nrow=2,ncol=1)),
              varLabels=list(rep("varLabel1",1))), channels=channels)		
      Re1 <- qualityParameters(arrayDataObject=arrayDataObject, exprSetRGObject=exprSetRGObject, identifiersToBeSkipped= "Blank")
      stopifnot(all.equal.numeric(as.numeric(Re1$qualityParameters["H1",c("correlation")]),c(1)))
      stopifnot(Re1$replicateSpots==2)

   \dontshow{

      hybNames <- c(hybNames,hybNames)
      hybAttr=data.frame(slideName=I(hybNames))
      rawDataIntensityValues <- array(0, dim=c(6,2,2))
      dimnames(rawDataIntensityValues) <- list(NULL, c("green","red"), NULL)
      rawDataIntensityValues[,1,] <- c(R1,R1)
      rawDataIntensityValues[,2,] <- c(R2,R2)
      arrayDataObject <- new("arrayData", intensities=rawDataIntensityValues, hybAttrList=list(red=hybAttr,green=hybAttr), spotAttr=spotAttr)
      channels <- rbind(channels, channels+2)
      exprSetRGObject <- new("exprSetRG", 	
	exprs=matrix(c(R1,R1,R2,R2), nrow=6, byrow=FALSE), phenoData=	
             new("phenoData", pData=data.frame(matrix(0,nrow=4,ncol=1)),
              varLabels=list(rep("varLabel1",1))), channels=channels)
      Re1 <- qualityParameters(arrayDataObject=arrayDataObject, exprSetRGObject=exprSetRGObject, identifiersToBeSkipped= "Blank")
      stopifnot(Re1$replicateSpots==2)
      stopifnot(all.equal.numeric(as.numeric(unlist(Re1$qualityParameters[, grep( "spotReplicatesConcordance", colnames(Re1$qualityParameters) )])), rep(1,(length(hybNames)*length(grep( "spotReplicatesConcordance", colnames(Re1$qualityParameters)) ))) ))

      spotIdentifierVec <- c("Blank","A","A","A","B","B","B")
      R1 <- N1 <- c(10,1,1,1,2,2,2)
      R2 <- N2 <- c(11,2,2,2,4,4,4)
      rawDataIntensityValues <- array(0, dim=c(7,2,1))
      rawDataIntensityValues[,1,] <- R1
      rawDataIntensityValues[,2,] <- R2
      dimnames(rawDataIntensityValues) <- list(NULL, c("green","red"), NULL)
      spotAttr=data.frame(Name=I(spotIdentifierVec))
      hybNames <- "H1"
      hybAttr=data.frame(slideName=I(hybNames))
      arrayDataObject <- new("arrayData", intensities=rawDataIntensityValues, hybAttrList=list(red=hybAttr,green=hybAttr), spotAttr=spotAttr)
      indGreen=1
      indRed=2
      channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
      colnames(channels) <- c("green","red")
      exprSetRGObject <- new("exprSetRG", 	
	exprs=matrix(c(R1,R2), nrow=7, byrow=FALSE), phenoData=	
          new("phenoData", pData=data.frame(matrix(0,nrow=2,ncol=1)),
              varLabels=list(rep("varLabel1",1))), channels=channels)		


      Re2 <- qualityParameters(arrayDataObject=arrayDataObject, exprSetRGObject=exprSetRGObject, identifiersToBeSkipped= "Blank")

      stopifnot(all.equal.numeric(as.numeric(Re2$qualityParameters["H1",c("correlation")]),c(1)))
      stopifnot(Re2$replicateSpots==3)

      rawDataIntensityValues[1,1,1] <- NA
      intensities(arrayDataObject) <- rawDataIntensityValues
      Re2NA <- qualityParameters(arrayDataObject=arrayDataObject, exprSetRGObject=exprSetRGObject, identifiersToBeSkipped= "Blank")

      hybNames <- c("H1","H2")
      Xr1 <- Xn1 <- cbind(R1,R2)
      Xr2 <- Xn2 <- cbind(R2,R1)
      rawDataIntensityValues <- array(0, dim=c(7,2,2))
      rawDataIntensityValues[,1,1:2] <- Xr1
      rawDataIntensityValues[,2,1:2] <- Xr2
      dimnames(rawDataIntensityValues) <- list(NULL, c("green","red"), NULL)
      spotAttr=data.frame(Name=I(spotIdentifierVec))
      hybAttr=data.frame(slideName=I(hybNames))
      arrayDataObject <- new("arrayData", intensities=rawDataIntensityValues, hybAttrList=list(red=hybAttr,green=hybAttr), spotAttr=spotAttr)
      indGreen=1:2
      indRed=3:4
      channels <- matrix( c(indGreen,indRed), nrow=length(indGreen), byrow=FALSE )
      colnames(channels) <- c("green","red")
      exprSetRGObject <- new("exprSetRG", 	
	exprs=as.matrix(cbind(Xr1,Xr2)), phenoData=	
          new("phenoData", pData=data.frame(matrix(0,nrow=4,ncol=1)),
              varLabels=list(rep("varLabel1",1))), channels=channels)	   

      Re3 <- qualityParameters(arrayDataObject=arrayDataObject,
                               exprSetRGObject=exprSetRGObject,
                               identifiersToBeSkipped= "Blank",
                               resultFileName=file.path(tempdir(),"qP.txt"))

      Re3 <- qualityParameters(arrayDataObject=arrayDataObject,
                               exprSetRGObject=exprSetRGObject,
                               identifiersToBeSkipped= "Blank")

      stopifnot(all.equal.numeric(as.numeric(Re3$qualityParameters["H2",c("correlation")]),c(1)))
      stopifnot(Re3$replicateSpots==3)
      exprs(exprSetRGObject)[2,c(2:4)] <- 0
      Re3 <- qualityParameters(arrayDataObject=arrayDataObject,
                               exprSetRGObject=exprSetRGObject,
                               identifiersToBeSkipped= "Blank")
      redHTwo <- median( c(sd(c(0,1,1)), sd(c(2,2,2) )))
      redHOnegreenHTwo <- median( c(sd(c(0,2,2)), sd(c(4,4,4) )))
      stopifnot( all.equal.numeric(Re3$qualityParameters$spotReplicatesConcordance.MedianSDGreen[2],redHOnegreenHTwo) )
      stopifnot( all.equal.numeric(Re3$qualityParameters$spotReplicatesConcordance.MedianSDRed, c(redHOnegreenHTwo, redHTwo) ) )
   }

	}

 \keyword{utilities}

 \author{Andreas Buness <a.buness@dkfz.de>}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End of File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
