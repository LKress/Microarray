%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file was automatically generated by Rdoc on 2006-11-09 20:13:25.
% Do NOT modify this file, instead modify the source (/net/lima/export/raid1/rzpd/home/buness/R/Rpacks/arrayMagic/R/normalise.R).
% Rdoc is copyright (C) 2001, Henrik Bengtsson, henrikb@braju.com.
% Download the Rdoc compiler at http://www.braju.com/R/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


 \name{normalise}

 \title{Normalisation of microarray data}

 \alias{normalise}

 \keyword{utilities}

 \usage{normalise(arrayDataObject, subtractBackground = FALSE, method = "vsn", subGroups = NULL, channelsSeparately = FALSE, hybridisationGroups, spotIdentifier, verbose = TRUE, ...)}

 \description{An object of class \code{\link{exprSetRG}} is generated
              which contains the resulting normalised data.}

 \arguments{
  \item{arrayDataObject}{object of class \code{\link{arrayData}};
                         required; default missing.
                 \code{arrayDataObject} must contain the raw data, i.e.
                 a three dimensional array
                 (spot x channel x hybridisation),
                 cf. the class methods \code{\link{getIntensities}}
                 and \code{\link{intensities<-}},
                 and must contain information
                 on the hybridisations,
                 cf. class methods \code{\link{getHybAttr}} and
                 \code{{hybAttrList<-}}.
                 If the argument \code{subGroups} (see below)
                 is specified it must also contain 
                 information on the spots, cf. the class methods
                 \code{\link{getSpotAttr}} and
                 \code{\link{spotAttr<-}}.
                 Note: Weights are only used by loess-type normalisations.
                }
  \item{subtractBackground}{logical; default: \code{FALSE}}
  \item{method}{character string; required; default: "\code{vsn}";
        possible values:
        "\code{none}", "\code{vsn}", "\code{quantile}",
        "\code{loess}", "\code{loessScale}", "\code{loessQuantile}".
        Note: "\code{quantile}" and  "\code{loess*}" normalisation
              transform the data to the (natural) logarithmic scale.
        Note: Weights are only used by loess-type normalisations.
        Note: "\code{loessScale}" and "\code{loessQuantile}" refer
              to a loess normalisation followed by a
              between slide/ \code{subGroups} normalisation, cf. the function
              \code{normalizeBetweenArrays} of the
              \code{limma} package.
        Note: "\code{quantile}" and  "\code{loess*}" normalisations
              do call the corresponding methods of the \code{limma} package
              and "\code{vsn}" uses the \code{vsn} package.
        }
  \item{subGroups}{character string or \code{NULL};
                   required; default: \code{NULL};
                   \code{subGroups} allows to define subgroups
                   of spots of each hybridisation
                   which are normalised separately like a 
                   print-tip normalisation
                   (Note: the between slide/ \code{subGroups} normalisation of
                    "\code{loessScale}" and "\code{loessQuantile}"
                    is separately applied for each subgroup). 
                   The list must contain a column name refering to the
                   \code{data.frame} of \code{getSpotAttr(arrayDataObject)}.
                   In case of GenePix data you may for example
                   specify the column name "Block".
                   The column itself must contain integer values.
                   Note: In case of \code{method == "vsn"},
                   \code{vsn} is called with
                   the argument \code{strata}, which differs
                   from a separate normalisation of each subgroup
                   with \code{vsn} itself. 
                   }
  \item{channelsSeparately}{logical; required; default: \code{FALSE};
                            If \code{channelsSeparately} ist set to \code{TRUE}
                            each channel is normalised separately. Only meaningful
                            for single channel normalisation methods like
                            "\code{vsn}" and
                            "\code{quantile}" normalisation
                            but not for ratio based
                            normalisation like "\code{loess}".}
  \item{hybridisationGroups}{list of vectors of indexes or
                             the character string "slideBySlide";
                             optional; default: missing.
                             Each group of hybridisations
                             is normalised separately. If
                             missing all hybridisations are
                             taken as one group. Only meaningful for
                             normalisation methods like "vsn" and "quantile".
                             The indexes must refer to the third
                             dimension of \code{getIntensities(arrayDataObject)}
                             and have to contain all hybridisations.
                             }
  \item{spotIdentifier}{ character string; optional; default missing.
                         \code{spotIdentifier} specifies the column
                         of \code{getSpotAttr(arrayDataObject)} which must
                         contain non-unique spot or gene identifiers.
                         The identifiers are used as names for the
                         resulting \code{exprSetRG}-object; cf. the function
                         \code{geneNames} of the \code{exprSetRG-class}. }
  \item{verbose}{ logical; required; default: \code{TRUE}}
  \item{...}{ further arguments which are passed to \code{vsn} if
              "\code{vsn}" is specified for normalisation.
              The arguments must not include \code{strata} and \code{verbose}.
            }

 }

 \value{object of class \code{\link{exprSetRG}} }

 \seealso{ 
           \code{\link{exprSetRG-class}},
           \code{\link{processArrayData}},
           \code{\link{processArrayDataObject}}
         }

 \author{Andreas Buness <a.buness@dkfz.de>}
 \examples{

       intensities <- array(data=runif(720),dim=c(120,2,3))
       dimnames(intensities) <- list(NULL, c("green","red"), NULL)
       hybAttr <- data.frame(Name=I(c("hx","hy","hz")), Index=c(1:3))
 	arrayDataObject <- new("arrayData",
                              intensities=intensities,
                              hybAttrList=list(red=hybAttr,green=hybAttr)
                             )
       exprSetRGObject <- normalise(arrayDataObject = arrayDataObject,
                               subtractBackground = FALSE,
                               method = "none",
                               verbose = TRUE
                               )
       nRed <- exprs(getExprSetRed(exprSetRGObject))
       nGreen <- exprs(getExprSetGreen(exprSetRGObject))
       stopifnot( all.equal.numeric( as.vector(nRed), as.vector(intensities[,"red",] )))
       stopifnot( all.equal.numeric( as.vector(nGreen), as.vector(intensities[,"green",] )) ) 

   \dontshow{
       exprSetRGObject <- normalise(arrayDataObject = arrayDataObject,
                               subtractBackground = FALSE,
                               method = "none",
                               channelsSeparately = TRUE,
                               verbose = TRUE
                               )
       nRed <- exprs(getExprSetRed(exprSetRGObject))
       nGreen <- exprs(getExprSetGreen(exprSetRGObject))
       stopifnot( all.equal.numeric( as.vector(nRed), as.vector(intensities[,"red",] ) ))
       stopifnot( all.equal.numeric( as.vector(nGreen), as.vector(intensities[,"green",] ) ))

       exprSetRGObject <- normalise(arrayDataObject = arrayDataObject,
                               subtractBackground = FALSE,
                               method = "none",
                               hybridisationGroups= list(c(1,3),2),
                               verbose = FALSE
                               )
       nRed <- exprs(getExprSetRed(exprSetRGObject))
       nGreen <- exprs(getExprSetGreen(exprSetRGObject))
       stopifnot( all.equal.numeric( as.vector(nRed), as.vector(intensities[,"red",] ) ))
       stopifnot( all.equal.numeric( as.vector(nGreen), as.vector(intensities[,"green",] ) ) )

       exprSetRGObject <- normalise(arrayDataObject = arrayDataObject,
                               subtractBackground = FALSE,
                               method = "none",
                               channelsSeparately = TRUE,
                               hybridisationGroups= list(c(2,3),1),
                               verbose = TRUE
                               )
       nRed <- exprs(getExprSetRed(exprSetRGObject))
       nGreen <- exprs(getExprSetGreen(exprSetRGObject))
       stopifnot( all.equal.numeric( as.vector(nRed), as.vector(intensities[,"red",] ) ))
       stopifnot( all.equal.numeric( as.vector(nGreen), as.vector(intensities[,"green",] ) ) )

       intensities <- array(data=runif(1440),dim=c(120,4,3))
       dimnames(intensities) <- list(NULL,
                                     c("green","red","greenBackground","redBackground"),
                                     NULL)
       intensities[,c("greenBackground","redBackground"),] <- -1
       hybAttr <- data.frame(Name=I(c("hx","hy","hz")), Index=c(1:3))
 	arrayDataObject <- new("arrayData",
                              intensities=intensities,
                              hybAttrList=list(red=hybAttr,green=hybAttr)
                             )
       exprSetRGObject <- normalise(arrayDataObject = arrayDataObject,
                               subtractBackground = TRUE,
                               method = "none",
                               channelsSeparately = TRUE,
                               hybridisationGroups= list(c(2,3),1),
                               verbose = TRUE
                               )
       nRed <- exprs(getExprSetRed(exprSetRGObject))
       nGreen <- exprs(getExprSetGreen(exprSetRGObject))
       stopifnot( all.equal.numeric( as.vector(nRed), as.vector((intensities[,"red",] + 1) ) ))
       stopifnot( all.equal.numeric( as.vector(nGreen), as.vector((intensities[,"green",] + 1) ) ))

   }      
 }

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% End of File
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
